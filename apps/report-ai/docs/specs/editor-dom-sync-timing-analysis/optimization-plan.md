# 优化方案 - 编辑器 DOM 同步性能优化

> 📖 [返回问题概览](./README.md) | 遵循 [Issue 文档编写规范](../../../../../docs/rule/issue-doc-rule.md)

## 方案对比

### 方案 1：智能变更检测（推荐）⭐

**核心思路**：检测本次变更是否涉及标题元素，只在必要时执行同步

**实施要点**：

1. 在 `handleContentChange` 中获取当前编辑节点
2. 检查节点是否为标题或标题的子节点
3. 只在涉及标题时调用 `requestDomSync()`

**优势**：

- 大幅减少不必要的同步（正文编辑占 90%+ 场景）
- 实现简单，改动最小
- 保持现有架构不变

**风险**：

- 需要准确判断变更类型（粘贴、删除等特殊操作）

**预计工作量**：1-2 天

### 方案 2：延迟执行

**核心思路**：将 RAF 改为 debounce（300ms），减少高频输入时的执行次数

**实施要点**：

1. 使用 lodash.debounce 替换 RAF
2. 保留 `syncNow` 用于立即同步场景

**优势**：

- 实现简单
- 减少执行频率

**劣势**：

- 延迟可能影响实时性（章节编号更新延迟）
- 无法解决全量扫描问题

**预计工作量**：0.5 天

### 方案 3：增量更新

**核心思路**：只检查当前编辑位置附近的标题

**实施要点**：

1. 使用 `editor.selection.getNode()` 获取当前节点
2. 向上查找最近的标题容器
3. 只处理当前章节及相邻章节

**优势**：

- 性能提升明显（O(n) → O(1)）

**劣势**：

- 实现复杂度高
- 可能遗漏跨章节操作（剪切粘贴）

**预计工作量**：3-5 天

### 方案 4：按需执行

**核心思路**：只在特定操作时执行（粘贴、插入标题、删除标题）

**实施要点**：

1. 移除 input 和 keyup 事件监听
2. 只保留 paste 和 change 事件
3. 监听 NodeChange 事件判断标题变化

**优势**：

- 执行频率最低

**劣势**：

- 可能遗漏某些边缘场景
- 需要全面测试

**预计工作量**：2-3 天

## 推荐方案

**采用方案 1（智能变更检测）+ 方案 2（延迟执行）组合**：

### 实施步骤

1. **第一阶段**：实现智能变更检测，过滤 90% 的不必要同步
2. **第二阶段**：如仍有性能问题，增加 debounce（100-200ms）

### 理由

- 方案 1 改动最小，风险可控
- 方案 2 作为补充，进一步优化高频场景
- 保持现有架构稳定性

### 预期效果

- **性能提升**：减少 90% 的不必要同步
- **用户体验**：大文档编辑更流畅
- **资源消耗**：CPU 占用显著降低

## 更新记录

| 日期       | 修改人 | 更新内容             |
| ---------- | ------ | -------------------- |
| 2025-10-29 | Kiro   | 从主文档拆分优化方案 |
