<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>像素风 Banner · 贪吃蛇 Demo</title>
    <style>
      :root {
        --bg: #ffffff;
        --fg: #111827; /* slate-900 */
        --sub: #4b5563; /* slate-600 */
        --accent: #0596b3; /* 主按钮色 */
        --accent-dark: #047a90; /* 主按钮深色 */
        --grid: #f3f4f6; /* 背景像素网格 */
        --card: #ffffff;
        --shadow: 0 10px 30px rgba(2, 6, 23, 0.08);
      }
      html,
      body {
        height: 100%;
        overflow: hidden; /* 禁止滚动 */
      }
      body {
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Noto Sans,
          Helvetica,
          Arial,
          'Apple Color Emoji',
          'Segoe UI Emoji';
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      .page {
        display: flex;
        flex-direction: column;
        height: 100%; /* 跟随 iframe 容器高度，避免裁剪 */
      }

      /* 顶部 */
      .nav {
        display: none; /* 去除头部占位，避免高度被挤爆 */
      }
      .brand {
        display: flex;
        gap: 10px;
        align-items: center;
        font-weight: 800;
        letter-spacing: 0.5px;
      }
      .brand .dot {
        width: 14px;
        height: 14px;
        background: var(--accent);
        box-shadow: 0 0 0 3px rgba(5, 150, 179, 0.25);
        image-rendering: pixelated;
      }

      /* Banner */
      .banner {
        position: relative;
        overflow: hidden;
        height: 100%; /* 跟随容器 */
      }
      .banner-inner {
        position: relative;
        max-width: 1120px;
        margin: 0 auto;
        /* padding: clamp(12px, 24px, 24px) clamp(12px, 24px, 24px); */
        display: grid;
        grid-template-columns: 1.1fr 0.9fr;
        gap: 24px;
        align-items: center;
        height: 100%; /* 满高并包含内边距 */
      }
      .banner::before {
        content: '';
        position: absolute;
        inset: 0;
        background:
          linear-gradient(90deg, var(--grid) 1px, transparent 1px) 0 0/16px 16px,
          linear-gradient(var(--grid) 1px, transparent 1px) 0 0/16px 16px;
        opacity: 0.7;
        pointer-events: none;
      }

      .title {
        font-size: clamp(28px, 4vw, 44px);
        line-height: 1.15;
        font-weight: 900;
        letter-spacing: 0.4px;
        margin: 0 0 12px;
      }
      .title .pixel {
        display: inline-block;
        text-shadow:
          2px 2px 0 #0001,
          4px 4px 0 #0001;
      }
      .desc {
        color: var(--sub);
        font-size: 16px;
        line-height: 1.7;
        margin: 0 0 24px;
      }

      .cta-row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .btn {
        position: relative;
        display: inline-block;
        padding: 12px 16px;
        font-weight: 800;
        text-decoration: none;
        color: #fff;
        background: var(--accent);
        border: 2px solid #047a90;
        box-shadow: 4px 4px 0 #047a90;
        image-rendering: pixelated;
      }
      .btn:hover {
        transform: translate(-1px, -1px);
        box-shadow: 6px 6px 0 #047a90;
        background: var(--accent-dark);
      }
      .btn:active {
        transform: translate(2px, 2px);
        box-shadow: 2px 2px 0 #047a90;
      }

      /* 右侧演示卡 */
      .demo-card {
        position: relative;
        background: var(--card);
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        box-shadow: var(--shadow);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .demo-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 8px;
      }
      .leds {
        display: flex;
        gap: 6px;
      }
      .led {
        width: 8px;
        height: 8px;
        background: #e11d48;
        box-shadow: 0 0 0 2px #fecaca inset;
      }
      .led:nth-child(2) {
        background: #f59e0b;
        box-shadow: 0 0 0 2px #fde68a inset;
      }
      .led:nth-child(3) {
        background: #10b981;
        box-shadow: 0 0 0 2px #a7f3d0 inset;
      }

      .board {
        position: relative;
        background: #111827;
        border: 2px solid #000;
        border-radius: 10px;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        image-rendering: pixelated;
      }

      /* 小型测试徽章（不干扰 UI） */
      .test-badge {
        position: absolute;
        top: 8px;
        right: 8px;
        font-size: 12px;
        color: #6b7280;
        background: rgba(255, 255, 255, 0.85);
        padding: 2px 6px;
        border-radius: 6px;
        border: 1px solid #e5e7eb;
      }

      /* 响应式 */
      @media (max-width: 900px) {
        .banner-inner {
          grid-template-columns: 1fr;
          height: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="page">
      <section class="banner" id="demo">
        <div class="banner-inner">
          <!-- 左侧文案 -->
          <div>
            <h1 class="title">
              <span class="pixel">一句话找客户，</span><br /><span class="pixel">像素级爽快体验</span>
            </h1>
            <div class="cta-row">
              <a id="cta-use-now" class="btn" href="#try">立即使用</a>
            </div>
          </div>

          <!-- 右侧演示卡：像素风贪吃蛇 -->
          <div class="demo-card">
            <div class="demo-head">
              <div class="leds"><span class="led"></span><span class="led"></span><span class="led"></span></div>
              <small style="color: #6b7280">Press ↑ ↓ ← →</small>
            </div>
            <div class="board" style="aspect-ratio: 16/10">
              <div id="test-badge" class="test-badge">Tests: running…</div>
              <canvas id="snake"></canvas>
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      // —— 像素贪吃蛇（自适应 banner） ——
      ;(function () {
        const canvas = document.getElementById('snake')
        const ctx = canvas.getContext('2d', { alpha: false })
        const badge = document.getElementById('test-badge')

        let W, H, CELL, COLS, ROWS
        function resize() {
          const board = canvas.parentElement.getBoundingClientRect()
          const targetW = Math.floor(board.width)
          const targetH = Math.floor(board.height)
          CELL = Math.max(10, Math.floor(targetW / 40)) // 约 40 列
          COLS = Math.max(20, Math.floor(targetW / CELL))
          ROWS = Math.max(12, Math.floor(targetH / CELL))
          W = COLS * CELL
          H = ROWS * CELL
          canvas.width = W
          canvas.height = H
          ctx.imageSmoothingEnabled = false
        }

        // —— 状态 ——
        let snake,
          dir,
          foods = [],
          timer = null,
          speed = 100,
          running = false // 先暂停用于跑测试

        function reset() {
          snake = []
          const len = 6
          const r = Math.floor(ROWS / 2),
            c0 = Math.floor(COLS / 3)
          for (let i = 0; i < len; i++) snake.push({ x: c0 - i, y: r })
          dir = { x: 1, y: 0 }
          foods = []
          fillFoods()
        }

        function randomFood() {
          return {
            x: Math.floor(Math.random() * COLS),
            y: Math.floor(Math.random() * ROWS),
          }
        }

        // 生成较多食物，避免与蛇/已有食物重叠
        function fillFoods() {
          const target = Math.max(8, Math.floor((COLS * ROWS) / 120))
          let guard = 0
          while (foods.length < target && guard < 2000) {
            guard++
            const f = randomFood()
            const hitSnake = snake.some((s) => s.x === f.x && s.y === f.y)
            const hitFood = foods.some((g) => g.x === f.x && g.y === f.y)
            if (!hitSnake && !hitFood) {
              foods.push(f)
            }
          }
        }

        function step() {
          if (!running) return
          // 让自动演示略微带点随机
          if (Math.random() < 0.08) {
            const choices = [
              { x: 1, y: 0 },
              { x: -1, y: 0 },
              { x: 0, y: 1 },
              { x: 0, y: -1 },
            ].filter((v) => v.x !== -dir.x || v.y !== -dir.y)
            dir = choices[Math.floor(Math.random() * choices.length)]
          }
          const head = {
            x: (snake[0].x + dir.x + COLS) % COLS,
            y: (snake[0].y + dir.y + ROWS) % ROWS,
          }
          // 自咬则重置，保持 Demo 流畅
          if (snake.some((s) => s.x === head.x && s.y === head.y)) {
            reset()
          } else {
            snake.unshift(head)
            const eatIdx = foods.findIndex((f) => f.x === head.x && f.y === head.y)
            if (eatIdx !== -1) {
              foods.splice(eatIdx, 1) // 吃到 -> 增长（不 pop 尾）
              fillFoods()
            } else {
              snake.pop()
            }
          }
          draw()
        }

        function draw() {
          // 背景棋盘
          ctx.fillStyle = '#0b1220'
          ctx.fillRect(0, 0, W, H)
          for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
              if (((x + y) & 1) === 0) {
                ctx.fillStyle = '#0e172a'
                ctx.fillRect(x * CELL, y * CELL, CELL, CELL)
              }
            }
          }
          // 食物（像素苹果们）
          for (const f of foods) {
            px(f.x, f.y, '#f43f5e')
            ctx.fillStyle = '#fecaca'
            ctx.fillRect(
              f.x * CELL + Math.floor(CELL * 0.2),
              f.y * CELL + Math.floor(CELL * 0.2),
              Math.max(1, Math.floor(CELL * 0.2)),
              Math.max(1, Math.floor(CELL * 0.2))
            )
          }
          // 蛇
          for (let i = snake.length - 1; i >= 0; i--) {
            const s = snake[i]
            const shade = Math.max(0, 180 - (snake.length - i) * 3)
            px(s.x, s.y, `hsl(160deg 80% ${Math.max(25, shade / 2)}%)`)
          }
          // 外框像素描边
          ctx.strokeStyle = '#000'
          ctx.lineWidth = 2
          ctx.strokeRect(1, 1, W - 2, H - 2)
        }

        function px(x, y, color) {
          ctx.fillStyle = color
          ctx.fillRect(x * CELL, y * CELL, CELL, CELL)
          // 轻微像素内阴影
          ctx.fillStyle = 'rgba(0,0,0,.12)'
          ctx.fillRect(x * CELL, y * CELL + Math.floor(CELL * 0.7), CELL, Math.ceil(CELL * 0.3))
        }

        // 键盘接管 & 点击暂停/继续
        window.addEventListener('keydown', (e) => {
          const v = {
            ArrowUp: { x: 0, y: -1 },
            ArrowDown: { x: 0, y: 1 },
            ArrowLeft: { x: -1, y: 0 },
            ArrowRight: { x: 1, y: 0 },
          }[e.key]
          if (v && (v.x !== -dir.x || v.y !== -dir.y)) dir = v
        })
        canvas.addEventListener('click', () => {
          running = !running
          if (running) tick()
        })

        function tick() {
          if (timer) cancelAnimationFrame(timer)
          let last = 0
          function loop(t) {
            if (!running) return // 暂停
            if (t - last > speed) {
              last = t
              step()
            }
            timer = requestAnimationFrame(loop)
          }
          timer = requestAnimationFrame(loop)
        }

        // —— 简易测试（不更改 UI & 逻辑） ——
        function runTests() {
          const results = []
          const assert = (name, cond) => {
            results.push({ name, pass: !!cond })
          }

          // T1: randomFood 位于边界内
          let within = true
          for (let i = 0; i < 100; i++) {
            const f = randomFood()
            if (f.x < 0 || f.x >= COLS || f.y < 0 || f.y >= ROWS) {
              within = false
              break
            }
          }
          assert('T1 randomFood within bounds', within)

          // T2: fillFoods 不与蛇重叠 & 唯一
          reset()
          const map = new Set(foods.map((f) => `${f.x},${f.y}`))
          const overlap = foods.some((f) => snake.some((s) => s.x === f.x && s.y === f.y))
          assert('T2 foods not overlap snake', !overlap)
          assert('T3 foods are unique', map.size === foods.length)

          // T4: step 吃到食物后长度 +1
          const head = snake[0]
          const next = {
            x: (head.x + dir.x + COLS) % COLS,
            y: (head.y + dir.y + ROWS) % ROWS,
          }
          // 确保下一格有食物
          if (!foods.some((f) => f.x === next.x && f.y === next.y)) foods.push({ x: next.x, y: next.y })
          const len0 = snake.length
          running = true
          step()
          running = false
          assert('T4 eat increases length', snake.length === len0 + 1)

          // T5: 自咬触发 reset()
          // 构造一个会自咬的形状：一个 3 节回头
          snake = [
            { x: 5, y: 5 },
            { x: 6, y: 5 },
            { x: 6, y: 6 },
            { x: 5, y: 6 },
            { x: 4, y: 6 },
          ]
          dir = { x: 1, y: 0 } // 前进一步将与 (6,5) 碰撞
          const LEN_BEFORE = snake.length
          running = true
          step()
          running = false
          assert('T5 self-collision resets to 6', snake.length === 6)

          // 输出
          const failed = results.filter((r) => !r.pass)
          if (badge) {
            badge.textContent = failed.length === 0 ? 'Tests: all passed ✓' : `Tests: ${failed.length} failed ✗`
            // 3 秒后淡隐
            setTimeout(() => {
              badge.style.display = 'none'
            }, 3000)
          }
          // 控制台也输出详情
          console.table(results)

          // 恢复干净状态
          reset()
        }

        // 初始化
        resize()
        reset()
        draw()
        runTests()
        running = true // 测试后启动自动播放
        tick()
        new ResizeObserver(() => {
          resize()
          draw()
        }).observe(canvas.parentElement)
        // —— CTA: 点击“立即使用”通知父页面 ——
        const cta = document.getElementById('cta-use-now')
        if (cta) {
          cta.addEventListener('click', (e) => {
            e.preventDefault()
            try {
              if (window.parent) {
                window.parent.postMessage({ type: 'banner/cta', action: 'openModal' }, '*')
              }
            } catch (_) {}
          })
        }
      })()
    </script>
  </body>
</html>
