# 项目深挖底稿：Report Print & Preview PDF 生成应用

- **定位**：面试口述脚本 & 答辩思维导图
- **基线版本**：2024.05 - 2024.09 | 核心开发

## 1. 叙事构建逻辑 (Narrative Construction)

### 模块一：电梯演讲 (The Hook / 1 min)

**[业务背景]** 这是一个为企业征信报告提供“所见即所得”的 PDF 导出服务，支持 30 多种复杂的报告模板。
**[核心职责]** 我主要负责**双模渲染引擎**的搭建和**复杂分页算法**的实现。
**[最大痛点]** 最大的挑战是**兼容性与精度的矛盾**。我们要生成符合出版标准的 PDF（wkhtmltopdf），但它基于古老的 QT WebKit 内核，不支持现代 CSS/JS；同时还要处理跨页表格的表头重复和富文本截断问题。
**[解决方案]** 我设计了 **Vite (预览) + Webpack (打印)** 的双构建架构来解决开发效率与兼容性问题，并实现了一套**基于 DOM 的迭代式分页算法**。
**[最终收益]** 实现了像素级的打印还原，PDF 体积比 Puppeteer 方案小 80%，且完美解决了长表格跨页截断的业界难题。

### 模块二：STAR 深度复盘 (The Deep Dive)

#### S (Background / 场景痛点)
做过打印的都知道，PDF 导出是前端的噩梦。
1.  **环境恶劣**：服务端渲染用的 `wkhtmltopdf` 就像是 10 年前的 IE 浏览器，不支持 Flexbox，不支持 ES6+。
2.  **布局复杂**：报表里有大量跨页的长表格，要求表头在每一页自动重复（Thead Repetition），且单元格内的富文本如果跨页，不能简单截断，否则 HTML 标签未闭合会毁掉整个页面。

#### T (Task / 限制条件)
*   **高保真**：打印出来的 PDF 必须和网页预览一模一样。
*   **稳定性**：批量导出 1000 份报告不能崩。

#### A (Action / 关键决策与行动)

**1. 架构设计：双模渲染引擎 (Dual Engine)**
*   **问题**：如果在开发环境也用 Webpack 转译 ES5，构建太慢，HMR 只有几秒延迟，开发体验极差。
*   **解决**：我搞了两套构建流程。
    *   **Preview Mode**：用 **Vite + React 18**，开发爽，秒级热更。
    *   **Print Mode**：用 **Webpack 5 + Babel**，强制注入 Polyfill（甚至降级用 jQuery），专门伺候 QT WebKit。
    *   **关键点**：通过抽取公共组件库（`gel-ui`）保证两套环境的 UI 逻辑一致。

**2. 核心算法：迭代式 DOM 分页 (Iterative DOM Fitting)**
*   **痛点**：一个单元格里有一大段 HTML 富文本，跨页时怎么切？简单 `substring` 会切断 HTML 标签。
*   **方案**：
    *   我写了一个 **CellSplitter**。
    *   它不是算字符数，而是把 HTML 解析成一个个 Unit（标签或文本节点）。
    *   然后像搭积木一样，把 Unit 一个个往临时容器里塞，每塞一个就算一下高度。
    *   一旦超出一页高度，回退最后一个 Unit，并在切断处**自动补全闭合标签**。
    *   这确保了跨页处的样式绝对正确，不会出现“半个加粗标签”这种 bug。

**3. 稳定性：进程守护 (Process Guardian)**
*   **问题**：wkhtmltopdf 有内存泄漏 bug，跑几百个任务就死锁。
*   **解决**：
    *   我在 Node.js 层做了**进程池**管理。
    *   给每个生成任务设置 30s 超时。
    *   如果超时或报错（EPIPE），自动杀进程并重试（Retry Strategy）。

#### R (Result / 结果与收益)
*   **性能**：PDF 平均体积仅 500KB（Puppeteer 生成的同类文件要 3MB+）。
*   **质量**：长表格跨页、表头重复、文本截断全部自动化完美处理。

## 2. 防御性推演 (Defensive Strategy)

### 策略 A：技术选型质疑 (Trade-off)

*   **Trigger**：为什么不用 Puppeteer？它是 Chrome 内核，兼容性不是更好吗？
*   **A (脚本)**：
    *   **承认优势**：Puppeteer 确实兼容性好，开发简单。
    *   **致命缺陷**：但它生成的 PDF 是基于图片的（或者包含大量冗余数据），**体积太大**。我们的报告需要邮件发送，客户对附件大小很敏感。
    *   **wkhtmltopdf 优势**：它生成的是矢量 PDF，文字就是文字，清晰度高且体积极小（小 80%）。为了这个收益，我们愿意承担兼容性适配的成本。

### 策略 B：深度原理挖掘 (Under the Hood)

*   **Trigger**：你是怎么保证预览和打印样式一致的？毕竟浏览器内核不同。
*   **A (脚本)**：
    *   **CSS 策略**：我们放弃了 Flex 和 Grid 布局，回归了更稳健的 `Float` 和 `Table` 布局。这是两端都支持的子集。
    *   **像素对齐**：禁用了 wkhtmltopdf 的智能缩放，强制 DPI 为 96，并通过 CSS `@page` 严格控制毫米级的边距。

### 策略 C：不足与反思 (Deficiency & Pivot)

*   **Trigger**：遇到过什么坑？
*   **A (脚本)**：
    *   **事故**：上线初期，PDF 里的 ECharts 图表经常是空白的。
    *   **Root Cause**：wkhtmltopdf 默认在 `window.onload` 后就截图，但 React 和 ECharts 的渲染是异步的，那时候图还没画好。
    *   **Pivot**：引入了**信号机制**。
        *   在页面里定义 `window.status`。
        *   等所有图表渲染完（监听 `finished` 事件），把 status 设为 `'ready'`。
        *   告诉 wkhtmltopdf `--window-status ready`，强制它等待这个信号再截图。

## 3. 模拟对练 (Simulation)

*   **Round 1**：如果表格太宽怎么处理？（答：检测宽度溢出，自动缩小 `zoom` 比例，或者旋转页面为横向。）
*   **Round 2**：如何处理中文字体缺失问题？（答：Docker 镜像中预装 Google Noto CJK 字体，并配置 `font-family` 降级策略。）
*   **Round 3**：分页计算为什么不在后端做？（答：后端不知道前端渲染后的真实字体高度（Font Metrics），只有浏览器渲染引擎知道。前端计算是唯一精确解。）
