# 项目深挖底稿：企业详情页重构

- **定位**：面试口述脚本 & 答辩思维导图
- **基线版本**：2023.06 - 至今 | 核心开发

## 1. 叙事构建逻辑 (Narrative Construction)

### 模块一：电梯演讲 (The Hook / 1 min)

**[业务背景]** 这是一个聚合了工商、财务、司法等 50 多个维度的企业数据详情页，是投资分析师的核心工作台。
**[核心职责]** 我主导了**配置化驱动架构**的重构和**长列表性能优化**。
**[最大痛点]** 随着业务发展，我们要支持 IPO、基金、海外等多种特殊企业类型，旧代码里全是 `if (isIPO)` 这样的硬编码，维护极其痛苦；同时 50 多个模块一次性渲染导致首屏极慢。
**[解决方案]** 我设计了一套**配置合成策略**，将业务逻辑与 UI 解耦，实现了“千企千面”的自动适配；并引入**智能滚动懒加载**机制。
**[最终收益]** 最终将逻辑复用率提升了 80%，首屏接口请求减少了 90%（按需加载），滚动帧率稳定在 60FPS。

### 模块二：STAR 深度复盘 (The Deep Dive)

#### S (Background / 场景痛点)
这不是一个简单的详情页，它更像是一个复杂的 Dashboard。
*   **复杂度高**：一个页面包含 50+ 个业务模块，每个模块都有独立的表格或图表。
*   **差异化大**：一家上市公司和一家私募基金，展示的维度完全不同（比如基金有“管理人”，上市公司有“募集资金”）。
*   **历史包袱**：老代码为了兼容各种企业类型，写了无数的 `if-else`，改一个 bug 能引发三个新 bug。

#### T (Task / 限制条件)
*   **可维护性**：必须用一套代码支持所有企业类型，拒绝复制粘贴。
*   **性能指标**：首屏 TTI (Time to Interactive) 必须控制在 3 秒内，滚动过程不能有任何掉帧。

#### A (Action / 关键决策与行动)

**1. 架构重构：配置驱动 (Config-Driven Development)**
*   **拒绝硬编码**：我把所有模块的元数据（API、组件映射、依赖字段）抽离成了 `listRowConfig`。
*   **策略模式**：设计了一个 `useCorpMenuByType` Hook。
    *   它不像以前那样写死判断逻辑。
    *   而是采用**策略合成**：先拉取 `BaseConfig`，再根据企业类型（如 IPO）自动 merge 对应的 `SpecialConfig`。
    *   最后结合数据统计（`basicNum`）自动过滤掉无数据的模块。
    *   这让增加一种新企业类型变成了纯配置工作，完全不需要改组件代码。

**2. 性能优化：智能滚动懒加载 (Smart Scroll Lazy Loading)**
*   **问题**：50 个模块如果全量渲染，DOM 节点数破万，浏览器直接卡死。
*   **方案**：
    *   **虚拟占位**：可视区之外的模块，只渲染一个高度固定的 Skeleton（骨架屏），不挂载真实组件，不请求接口。
    *   **智能预加载**：监听滚动速度和方向，动态计算“预加载阈值”。比如用户向下快滑时，我会提前加载可视区下方 2 个屏幕的模块，平衡了网络请求和渲染压力。

**3. 交互优化：高频事件帧对齐**
*   **痛点**：左侧菜单需要随滚动实时高亮，`onScroll` 触发频率太高（100次/秒），计算 `offsetTop` 会导致强制重排（Reflow）。
*   **解决**：
    *   **读写分离**：在页面初始化时，一次性把所有模块的位置信息缓存到 Ref 中（Read）。
    *   **帧对齐**：在滚动回调里，只做纯数值比对，并且用 `requestAnimationFrame` 节流，确保每一帧只执行一次高亮更新（Write）。

#### R (Result / 结果与收益)
*   **研发效能**：新增一种企业类型的时间从 3 天缩短到 0.5 天（改配置即可）。
*   **性能体验**：首屏接口数从 50+ 降到了 5 个以内，长列表滚动如丝般顺滑。
*   **代码质量**：彻底消除了 `if-else` 逻辑陷阱。

## 2. 防御性推演 (Defensive Strategy)

### 策略 A：技术选型质疑 (Trade-off)

*   **Trigger**：为什么要搞这么复杂的配置化？直接写组件不行吗？
*   **A (脚本)**：
    *   **承认成本**：配置化初期确实增加了抽象成本，需要定义 Schema。
    *   **场景反转**：但是我们的业务形态决定了企业类型会不断增加（最近刚加了“海外版”）。
    *   **对比收益**：如果继续写组件，每加一种类型就要 copy 一份代码，维护成本是 O(N)；用配置化，维护成本是 O(1)。而且配置化让我们具备了**低代码**的能力，未来甚至可以让产品经理直接配页面。

### 策略 B：深度原理挖掘 (Under the Hood)

*   **Trigger**：你的虚拟滚动和 `react-window` 这种库有什么区别？
*   **A (脚本)**：
    *   **原理区别**：`react-window` 适用于**等高**或**规律高度**的列表，它会复用 DOM 节点。
    *   **业务场景**：我们的模块高度差异极大（有的只有一行，有的有几十行表格），且包含复杂的交互组件，不适合 DOM 复用。
    *   **我的实现**：我实现的是**模块级的懒加载**。核心是“占位”——未进入视口时用 Skeleton 撑开高度，进入后替换为真实组件。这既减少了 DOM 数量，又保留了模块内部的复杂状态。

### 策略 C：不足与反思 (Deficiency & Pivot)

*   **Trigger**：这个系统出过生产事故吗？
*   **A (脚本)**：
    *   **真诚的不足**：出过。有一次上线，某个特供版企业页面白屏了。
    *   **Root Cause**：是因为该类型的配置表里漏配了对应的模块 Key，导致过滤后列表为空。这是配置化带来的副作用——运行时依赖配置正确性。
    *   **Pivot (改进)**：事后我加了两道防线：
        1.  **兜底逻辑**：配置为空时自动降级显示基础信息。
        2.  **工程化校验**：写了一个 Jest 测试脚本，在 Build 阶段自动扫描所有配置文件的完整性，确保所有注册类型都有对应的非空配置。

## 3. 模拟对练 (Simulation)

*   **Round 1**：如何处理锚点定位时的图片加载高度变化问题？（答：使用 ResizeObserver 监听模块高度变化，实时更新位置缓存。）
*   **Round 2**：如果用户直接访问 URL 带 hash 锚点，懒加载还没渲染怎么办？（答：初始化时优先加载 Hash 对应的模块，并使用 `scrollIntoView` 的 `behavior: smooth`。）
*   **Round 3**：Redux 在这里的作用是什么？（答：跨组件通信。滚动监听器在父组件，菜单在子组件，用 Redux 共享 `activeKey` 避免 Props 层层传递。）
