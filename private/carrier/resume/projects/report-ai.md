# Report-AI 报告生成应用 复盘档案

## 0. 受众与用途

- 受众：技术面试官（重点考察复杂状态管理与性能优化）
- 用途：面试复盘深挖，回答“最有挑战的项目”
- 叙述人称：第一人称（我）

## 1. 全景（Situation & Task）

- **业务背景**：这是一个面向金融分析师的 AI 研报生成平台。核心痛点是需要支持长达 50+ 页的专业研报生成，且用户在 AI 流式生成内容的同时，还需要进行高频的富文本编辑（修改、引用、格式调整）。
- **架构描述**：
  - 我采用了**三栏布局**：左侧为对话/大纲导航，中间为 TinyMCE 富文本编辑区，右侧为引用资料/预览。
  - **核心冲突**：AI 在写（流式注入）、人在写（富文本输入）、系统在存（自动保存）三者并发。
  - **数据流设计**：我设计了 **“事实层 - 草稿层 - 展示层” 三层一致性模型**。事实层（Fact）作为服务端 SSOT，草稿层（Draft）在前端 Redux 维护轻量级元数据与脏检查，展示层（Presentation）驱动编辑器 UI。
- **技术选型对比**：
  - **编辑器**：选择 TinyMCE 而非 Slate.js，因为金融场景需要完美的 Word 格式粘贴兼容和复杂的分页预览，自研成本过高。
  - **流式通道**：选择 SSE 单向推送，相比 WebSocket 更适合企业内网防火墙环境，且配合 HTTP/2 性能足够。
- **证据锚点**：
  - 《报告详情模块需求文档》`.../rp-detail/requirement.md` (模块概述/三栏布局)
  - 《AI 报告页面 - 技术设计总览》`.../rp-detail/design.md` (1.1-3.3 技术架构)
  - 《数据与状态（横向·三层指南）》`.../content-management/data-layer-guide.md` (1-3 层级定义)

## 2. 设计文档引用与要点（必须）

- **设计文档名称**：Report AI 项目文档库
- **设计文档路径**：
  - `private/carrier/assets/gel-workspace/apps/report-ai/docs/rp-detail/content-management/data-layer-guide.md`
  - `private/carrier/assets/gel-workspace/apps/report-ai/docs/rp-detail/content-management/edit-and-save-flow.md`
  - `private/carrier/assets/gel-workspace/apps/report-ai/docs/specs/editor-dom-sync-timing-analysis/optimization-plan.md`
- **关键章节引用**：
  - 《数据与状态指南》：定义了 Fact/Draft/Presentation 三层的职责边界。
  - 《编辑与保存流程》：规定了 Save 和 Edit 的互斥逻辑以及 Single-flight 队列机制。
  - 《DOM 同步性能优化》：记录了从全量扫描到按需同步的优化过程。

## 3. 核心功能与实现（Action - Construction）

- **功能 1：三层状态一致性管理**
  - 为了解决“AI 生成”与“用户编辑”的冲突，我严格区分了**事实层**（完整章节树）、**草稿层**（轻量级元数据、脏标记）和**展示层**（解析结果）。
  - **实现流程**：用户的任何输入先进入“归一化”处理，计算 Hash 比对判定脏状态，更新草稿层元数据，而非直接修改事实层数据，实现了编辑与数据存储的解耦。

- **功能 2：高并发下的保存/生成互斥**
  - **问题**：AI 流式生成时触发自动保存，或者保存未完成时用户继续输入，极易导致数据覆盖（ABA 问题）。
  - **实现流程**：我设计了 **Single-Flight 保存队列**。保存请求必须串行，前一个请求未返回前，后续触发只更新状态位不发请求。同时，在生成期间进入“只读/锁定”模式（或局部锁定），生成完成后刷新基线（Baseline），确保数据零丢失。

- **功能 3：流式注水与编辑器性能**
  - **问题**：长文档（50页+）的 DOM 节点数万，AI 流式吐字极快，频繁 `setContent` 会导致浏览器假死。
  - **实现流程**：我将流式数据按章节拆分，在非阻塞帧（Idle Callback）中计算 Diff，只对变化的章节进行增量更新。

- **证据锚点**：
  - 《数据与状态（横向·三层指南）》1-3 章
  - 《用户编辑与保存场景（纵向手册）》2-6 节 (保存链路)
  - 《全文生成场景》`.../full-generation-flow.md` (任务流程)

## 4. 个人执行与成果（Action & Result）

- **执行范围**：我独立负责了整个详情页的数据层架构设计、编辑器集成以及性能优化攻坚。
- **关键决策**：
  - 决策 1：放弃“实时全量同步”，改为“基于 Hash 的脏检查 + 按需同步”，大幅降低了 CPU 占用。
  - 决策 2：建立“首帧内容缓存”机制，解决了保存后内容闪回的顽疾。
- **量化结果**：
  - **稳定性**：上线后未发生一起因并发导致的数据覆盖或丢失事故。
  - **性能**：长文档编辑帧率稳定在 55-60 FPS，打字延迟低于 50ms。

## 5. 深挖案例（Action - Optimization & Result）

- **现象**：在 50 页以上的大文档中，用户每输入一个字，界面就会卡顿一下。性能分析显示 CPU 占用率飙升到 80% 以上。
- **排查过程**：
  - 我使用 Performance 面板录制，发现瓶颈在于 `updateStructure` 函数。
  - 原有逻辑是：编辑器内容变化 -> 触发 `input` 事件 -> **立即全量扫描 DOM** 提取大纲和标题编号 -> 更新 React 状态。
  - 对于大文档，高频的全量 DOM 扫描是灾难性的。
- **方案 V1（失败）**：
  - 尝试加入 `debounce`（防抖），延迟 500ms 执行。
  - **结果**：虽然卡顿少了，但用户输入标题后，左侧大纲的更新有明显滞后感，体验割裂，且并未解决扫描本身的开销。
- **方案 V2（最终）**：
  - 我重构了同步策略，引入**变更类型预判**。
  - 在输入链路中，先判断光标位置和输入内容。只有当用户修改了 H1-H6 标签、或者在标题行输入时，才标记为“结构性变更”。
  - 普通正文输入直接忽略，不触发 DOM 扫描。
  - 对于结构性变更，采用 `requestIdleCallback` 在浏览器空闲时执行扫描。
- **关键机制说明**：将“无脑全量同步”拆解为“基于意图的按需同步”。
- **量化结果**：
  - 标题编号同步频率降低了 **90%**（从次次触发变为仅标题修改触发）。
  - 编辑器输入时的 CPU 占用率从 80% 降至 **10-20%**。
  - 帧率恢复至 **55-60 FPS** 流畅水平。
- **证据锚点**：
  - 《编辑器 DOM 同步性能优化 - 问题分析》`.../issue-analysis.md`
  - 《编辑器 DOM 同步性能优化 - 验证计划》`.../verification-plan.md`

## 6. 事故复盘（可选）

- **时间线**：某次版本更新后，测试反馈：用户在保存成功的一瞬间，编辑器里的光标会乱跳，甚至内容会“闪回”到几秒前的状态。
- **根因**：
  - 保存成功后，后端返回了最新的文档数据。
  - 前端收到数据后，简单粗暴地调用了 `editor.setContent()` 刷新编辑器，试图保持前后端一致。
  - 但 TinyMCE 的 `setContent` 是异步且昂贵的，且会重置 Undo Stack 和光标位置。
- **行动项**：
  - 我修改了保存回调逻辑：保存成功后，**只更新基线 Hash (Baseline Hash)**，**绝不触碰编辑器内容**。
  - 只有在后端明确返回“数据结构已清洗/由他人修改”的特定状态码时，才提示用户刷新。
  - 引入“首帧内容缓存”，防止初始化时的重复注水。
- **证据锚点**：
  - 《Report Content Initial Value 问题修复》`.../2025-02-09-report-content-initial-value-issues/README.md`

## 7. 知识库（Legacy）

- **沉淀资产**：
  - **三层状态模型文档**：成为了团队处理复杂表单/编辑器场景的标准范式。
  - **性能排查手册**：记录了从 Performance 分析到优化落地的全过程。
- **注意事项**：
  - 在处理富文本编辑器时，永远不要信任 `onChange` 的频率，必须自己做调度控制。
  - "User Input is Truth"，在编辑状态下，不要轻易用后端数据覆盖前端。

## 8. 质量协议清单

- [x] 证据锚点检查（已关联 rp-detail, content-management, specs 等具体路径）
- [x] 文字化检查（纯文本，无代码）
- [x] 逻辑检查（三层模型解决并发，按需扫描解决卡顿）
- [x] 设计文档引用检查（精确到 docs 目录下的 md 文件）
- [x] 受众检查（面向面试官的深度复盘）
- [x] 第一人称叙述检查（我设计、我负责...）
