# 项目深挖底稿：Report Print & Preview PDF 生成应用

- **定位**：面试核心项目 dossier
- **模式**：Whitepaper (Dossier)
- **基线版本**：2024.05 - 2024.09 | 核心开发

## 0. 摘要 (Executive Summary)

**[业务背景]** 这是一个为企业征信报告提供“所见即所得”的 PDF 导出服务，支持复杂的动态报表模板。
**[核心挑战]** 最大的痛点是**兼容性与精度的矛盾**。我们需要在老旧的 `wkhtmltopdf` (Qt WebKit) 内核中，实现符合出版级标准的排版，同时解决跨页长表格的表头重复（Thead Repetition）和富文本截断等业界难题。
**[我的角色]** 我负责核心渲染引擎的搭建，重点实现了**双模渲染架构**与**基于 DOM 的迭代式分页算法**。
**[最终成果]** 实现了像素级的打印还原，解决了传统方案中 HTML 标签跨页截断导致的布局错乱问题，确保了 1000+ 份批量导出的稳定性。

---

## 1. 全景 (Situation & Task)

### 1.1 业务场景
*   **输入**：结构化的 JSON 报告数据 + 灵活的章节配置。
*   **输出**：可供打印的高保真 PDF。
*   **环境**：服务端使用 `wkhtmltopdf` 工具（基于旧版 WebKit 内核），对现代 CSS (Flex/Grid) 和 ES6+ 支持极差。

### 1.2 核心任务
*   **高保真还原**：必须保证预览页与打印出的 PDF 像素级一致。
*   **复杂分页处理**：
    *   **长表格跨页**：表格内容超过一页时，必须自动切分，并在新页头部自动重复表头。
    *   **富文本截断**：单元格内包含 HTML 富文本，跨页切分时不能简单截断字符串（会导致标签未闭合），必须保持 DOM 结构完整。
*   **稳定性**：在低版本浏览器内核中稳定运行，避免内存泄漏或静默失败。

### 1.3 技术约束
*   **内核限制**：`wkhtmltopdf` 行为类似于 10 年前的 Safari/IE，不支持大部分现代 Web 特性。
*   **选型决策**：
    *   为了保证在目标环境的绝对稳定性，我制定了 **ES5 + jQuery** 的技术基线，拒绝在渲染层引入 React/Vue 等重型框架，避免 Polyfill 带来的不可预知兼容性问题。
    *   布局采用稳健的 **Float + Table** 方案，而非 Flexbox。

---

## 2. 核心行动 (Action)

### 2.1 架构设计：多层职责分离 (Layered Architecture)

为了应对复杂的渲染逻辑，我设计了三层渲染架构，明确每一层的职责：

1.  **Page Manager (页面管理器)**：
    *   负责维护页面基准高度、页眉页脚的渲染。
    *   管理“当前页”的状态，提供“创建新页”、“检查剩余空间”等原子能力。
2.  **Table Processor (表格处理器)**：
    *   负责遍历表格数据，逐行追加内容。
    *   判断当前行是否溢出。如果溢出，决策是“整行迁移”还是“行内拆分”。
3.  **Row Splitter (行内拆分器)**：
    *   处理最棘手的“极端行”（高度超过页面的单行）。
    *   执行 DOM 级的拆分算法，将一行切分为“首段”和“剩余段”。

### 2.2 核心算法：迭代式 DOM 分页 (Iterative DOM Fitting)

这是本项目的核心难点。针对富文本跨页截断问题，我设计了一套**基于 HTML 单元的试探性拆分算法**：

*   **问题**：传统 `substring` 截断会切断 HTML 标签（如 `<b`），导致后续页面样式崩坏。
*   **算法流程**：
    1.  **解析 (Parse)**：将单元格内的 HTML 解析为最小原子单元（Units，如文本节点或完整标签）。
    2.  **试探 (Try-Fit)**：像搭积木一样，将 Units 逐个放入临时容器测量高度。
    3.  **回溯 (Backtrack)**：一旦总高度超过页面剩余空间，回退最后一个 Unit。
    4.  **补全 (Auto-Close)**：在切断处自动补全闭合标签，确保跨页处的 DOM 结构合法。
    5.  **回填 (Refill)**：将剩余的 Units 重新封装为新行，回填到待处理队列头部，在下一页继续渲染。

### 2.3 稳定性策略
*   **三层分页体系**：
    *   **阈值判断**：引入“接近满”阈值（如 80%）。如果当前页已接近满且下一行溢出，优先选择**整行迁移**到下一页，避免在页底留下尴尬的空白或只切分出一两行文字，提升阅读体验。
    *   **兜底机制**：当遇到无法拆分的超长内容（如单张超大图片）或算法异常时，提供降级处理（返回空首行，强制新页渲染），确保不会导致渲染进程卡死。

---

## 3. 结果与深挖 (Result & Deep Dive)

### 3.1 成果
*   **交付质量**：完美解决了长表格表头重复和富文本跨页截断问题，导出的 PDF 布局整齐，无样式错乱。
*   **性能收益**：相比于基于图片的生成方案（如 Puppeteer 截图），生成的矢量 PDF 体积显著更小（平均 ~500KB vs 3MB+），且文字清晰度更高。
*   **稳定性**：支持了 30+ 种复杂报表模板的稳定导出。

### 3.2 深度问答 (Defense Q&A)

**Q1: 为什么不用 Puppeteer (Chrome Headless)？它是更主流的方案。**
*   **A**:
    *   **体积问题**：Puppeteer 通常生成的是基于图片的 PDF（或包含大量冗余数据），体积往往很大（MB 级），不适合作为邮件附件发送。
    *   **清晰度**：图片放大后会失真，而我们生成的矢量 PDF 支持无损缩放。
    *   **环境依赖**：Puppeteer 需要完整的 Chrome 环境，部署成本和资源占用远高于轻量级的 `wkhtmltopdf`。

**Q2: 为什么在 2024 年还用 jQuery/ES5？**
*   **A**:
    *   这是基于**环境约束**的理性选择。`wkhtmltopdf` 的内核非常老旧，对 React/Vue 的合成事件、虚拟 DOM 兼容性极差。
    *   在“打印”这个单一场景下，我们需要的是**绝对的 DOM 控制力**和**零 Polyfill 风险**。jQuery 提供了最直接的 DOM 操作能力，非常适合这种“一次性渲染”的场景。

**Q3: 分页计算为什么不在后端做？**
*   **A**:
    *   **字体度量 (Font Metrics)**：后端无法精确获知浏览器渲染后的真实文字高度（受字体渲染引擎、字号、行高、字间距等影响）。
    *   只有在前端（浏览器环境）中，才能获取到 `offsetHeight` 等真实的渲染属性。前端计算是实现像素级精确分页的唯一解。

---

## 4. 证据索引 (Evidence Anchors)
> 这里的引用指向项目内的技术文档，用于面试复习时的深度查阅。

*   **架构原则**：《核心架构设计》 - `docs/core-architecture.md`
*   **渲染流程**：《核心渲染流程》 - `docs/core-rendering-flow.md`
*   **分页算法**：《PDF 自动分页流程与实现》 - `docs/pdf-pagination-process.md`
*   **行拆分细节**：《DOM 行分割算法与实现》 - `docs/dom-based-row-algorithm-implementation.md`
