# 项目深挖底稿：GEL Workspace Monorepo 工程化建设

- **定位**：面试核心项目 dossier
- **模式**：Whitepaper (Dossier)
- **基线版本**：2024.01 - 至今 | 架构师 & 项目经理

## 0. 摘要 (Executive Summary)

**[业务背景]** 随着团队扩张，我们维护着 8 个独立业务应用（Company, Report-AI 等）和 11 个公共库，面临着严重的“依赖地狱”和“重复造轮子”问题。
**[核心痛点]** 最痛的是 **CI 构建效率**，全量构建一次需要 40 多分钟，还经常因为内存溢出（OOM）挂掉，严重影响发版节奏。
**[我的角色]** 我主导了从多仓库（Multi-repo）到 **Monorepo** 的迁移与工程化重构。
**[最终成果]** 基于 **pnpm Workspace + Turborepo** 搭建了新的研发底座，将全量构建时间从 45 分钟压缩到了 **5 分钟**（热构建仅需 2 分钟），磁盘占用减少了 60%，并彻底消灭了“幽灵依赖”。

---

## 1. 全景 (Situation & Task)

### 1.1 现状与挑战
在迁移之前，我们的工程环境十分恶劣：
1.  **依赖混乱**：项目扫描显示，整个 workspace 里竟然有 12 个不同版本的 `lodash`，导致包体积臃肿不堪。
2.  **CI/CD 瓶颈**：简单的 `npm install && npm build` 串行执行，不仅慢（>40min），而且网络抖动会导致整个流水线失败。
3.  **流程割裂**：每个项目的启动命令、构建脚本都不一样，新人上手成本极高。

### 1.2 目标架构
构建一个统一、高效、标准化的研发底座。

*   **应用层**：8+ 独立应用 (Company SPA, Report AI, Print Service...)
*   **领域层**：`gel-ui` (UI 组件库), `cde` (核心逻辑), `detail-page-config` (配置引擎)
*   **基础层**：`gel-api` (Axios 封装), `gel-util`, `gel-types`

### 1.3 技术决策 (ADR)

| 决策点 | 选择 | 理由与收益 |
| :--- | :--- | :--- |
| **包管理** | **pnpm** | 1. **Hard Link**：大幅节省磁盘空间（~60%）。<br>2. **严格模式**：通过非扁平化 `node_modules` 结构，彻底根除“幽灵依赖”安全隐患。 |
| **构建编排** | **Turborepo** | 1. **性能**：基于 Go 编写，极快。<br>2. **远程缓存 (Remote Cache)**：CI 可复用上次构建产物，只构建变动的包（核心收益）。 |
| **开发工具** | **Vite** | 替代 Webpack，实现秒级 HMR，提升开发体验。 |

---

## 2. 核心行动 (Action)

### 2.1 核心攻坚：智能 CI 调度器 (Smart CI Scheduler)

针对 CI 环境网络不稳定和构建耗时问题，我没有仅依赖现成工具，而是定制了构建脚本：

*   **问题**：简单的 `pnpm -r build` 一旦某个子包构建失败（如网络超时），整个流水线就会崩溃，必须全盘重来。
*   **解决方案**：开发 `scripts/local-ci.js` 接管构建流程。
    1.  **拓扑排序**：分析依赖图，确保底层包（如 `gel-util`）先构建。
    2.  **进程隔离**：使用 `spawn` 独立运行每个包的构建任务，防止内存泄漏互相影响。
    3.  **智能重试队列**：捕获子进程 Exit Code，如果构建失败，自动进入重试队列（Retry Queue），最大重试 3 次。这极大地提高了流水线的通过率。

### 2.2 依赖治理：消灭“幽灵依赖”

*   **背景**：项目曾出现本地运行正常，上线后报错 `Module not found: Error: Can't resolve 'dayjs'`。
*   **根因**：npm/yarn v1 的扁平化依赖结构，使得代码可以非法访问 `package.json` 中未声明的“爷爷辈”依赖。
*   **治理**：
    *   全量迁移至 **pnpm**，开启严格模式。
    *   引入 `dependency-cruiser` 在 CI 阶段扫描依赖树，强制规范化依赖声明。
    *   利用 `pnpm dedupe` 将 12 个版本的 `lodash` 收敛为统一版本。

### 2.3 体验升级：统一 CLI
*   封装 `pnpm run start` 交互式命令行（基于 `prompts`）。
*   开发者无需记忆不同应用的端口号，只需选择应用名即可启动，且自动注入 `.env` 环境变量，抹平了本地与 CI 的配置差异。

---

## 3. 结果与深挖 (Result & Deep Dive)

### 3.1 核心指标
*   **构建速度**：全量构建从 45min -> 12min（优化依赖+并行）；**热构建（缓存命中）仅需 2min**。
*   **稳定性**：CI 通过率从 <60% 提升至 95%+（得益于智能重试机制）。
*   **规范化**：所有项目共享一套 `tsconfig`、`eslint` 和 `prettier` 配置，代码风格完全统一。

### 3.2 深度问答 (Defense Q&A)

**Q1: 为什么不直接用 Nx？Nx 功能不是更强大吗？**
*   **A**:
    *   **承认优势**：Nx 确实功能更全，插件生态更丰富。
    *   **场景适配**：我们的核心痛点是**构建速度**和**缓存**。Turborepo 的配置极其简单（只有一个 `turbo.json`），对现有代码的侵入性几乎为零，非常适合我们这种“边做业务边重构”的渐进式迁移场景。
    *   **学习成本**：Nx 的概念较多（Generators, Executors），团队上手成本较高；而 Turbo + pnpm 的组合更符合标准 Node.js 开发直觉。

**Q2: Monorepo 有带来什么新问题吗？如何解决？**
*   **A**:
    *   **问题**：**权限控制**变难了。以前不同仓库可以分别设置权限，现在都在一个库里。
    *   **解决**：我们引入了 GitHub 的 **CODEOWNERS** 机制。核心库（如 `gel-ui`）的修改必须经过架构组的 Review 才能合并，业务代码则由业务组 Owner 负责，实现了软性的权限隔离。
    *   **问题**：工具脚本依赖遗漏。例如 CI 脚本用了 `prompts` 但忘了加到 `devDependencies`，本地能跑是因为恰好别的包安装了。
    *   **解决**：把所有工程化脚本移到独立的 `packages/scripts` 包统一管理，并在 `preinstall` 钩子中做环境检查。

**Q3: pnpm 是怎么实现节省磁盘空间的？**
*   **A**:
    *   它利用了操作系统的 **Hard Link (硬链接)**。
    *   不同项目依赖同一个版本的 `react` 时，pnpm 只会在全局 store 里存一份物理文件，所有项目的 `node_modules` 里的文件都硬链接指向它。这不仅省空间，还让安装速度飞快。

---

## 4. 证据索引 (Evidence Anchors)
> 面试复习与深度查阅指引

*   **架构概览**：《GEL Workspace 架构白皮书》 - `docs/architecture-whitepaper.md`
*   **CI 优化**：《构建优化实战记录》 - `docs/ci-optimization-log.md`
*   **配置**：`turbo.json` (Pipeline 配置), `pnpm-workspace.yaml`
*   **脚本源码**：`scripts/local-ci.js` (智能调度核心逻辑)
