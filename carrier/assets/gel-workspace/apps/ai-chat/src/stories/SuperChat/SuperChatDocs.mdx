import { Meta } from '@storybook/blocks'

<Meta title="文档/SuperChat 会话管理" />

# SuperChat 会话管理机制

本文档详细介绍了 SuperChat 组件中的会话初始化与恢复机制，包括 URL 参数处理和历史消息恢复的实现逻辑。

## 1. 功能概述

SuperChat 组件支持两种主要的启动模式：

1. **新会话模式**：用户从首页或其他入口点击"新建会话"或带有初始消息的入口进入聊天页面
2. **会话恢复模式**：用户从历史记录列表中选择一个现有会话进入聊天页面

为了支持这两种模式，我们实现了一套逻辑，用于区分用户意图并正确处理会话状态。

## 2. URL 参数处理

系统支持以下 URL 参数：

| 参数               | 类型    | 说明                                                |
| ------------------ | ------- | --------------------------------------------------- |
| `initialMsg`       | string  | 初始消息内容，存在时表示这是一个带预填消息的新会话  |
| `initialDeepthink` | '0'/'1' | 初始深度思考模式状态，'1'表示启用                   |
| `conversationId`   | string  | 会话 ID，作为路由参数 `/super/chat/:conversationId` |

### URL 参数解析

使用 `useInitialMsgFromUrl` 钩子从 URL 中获取初始消息和深度思考模式：

```tsx
// 从 URL 中获取初始消息和深度思考模式
const { initialMessage, initialDeepthink, hasInitialMessage } = useInitialMsgFromUrl()
```

这个钩子不仅解析参数，还跟踪是否存在初始消息，以便后续逻辑判断。

## 3. 会话恢复机制

会话恢复机制基于以下核心原则：

- 如果存在初始消息参数 (`initialMsg`)，则始终视为新会话，不恢复历史消息
- 如果没有初始消息参数，且会话 ID 是有效的现有会话 ID，则恢复历史消息

### 关键实现：useChatSessionControl

`useChatSessionControl` 钩子封装了这一逻辑：

```tsx
const useChatSessionControl = (chatId: string, hasInitialMessage: boolean) => {
  // 决定是否应该恢复会话
  const shouldRestore = !hasInitialMessage && !chatId.startsWith('temp_')

  return {
    shouldRestore,
    // 其他会话控制相关状态和方法
  }
}
```

## 4. 新旧组件交互流程

以下是完整的交互流程：

1. **页面加载**：`SuperChat` 组件加载并解析 URL 参数
2. **会话控制初始化**：`useChatSessionControl` 根据 URL 参数决定处理方式
3. **条件性消息恢复**：基于 `shouldRestore` 决定是否恢复历史消息
4. **URL 参数清理**：处理完 URL 参数后，移除这些参数，防止重复处理

## 5. 实现注意事项

### 5.1 避免重复处理

为防止 URL 参数被重复处理，我们在参数处理后清除 URL：

```tsx
useEffect(() => {
  if (hasInitialMessage) {
    // 使用 replaceState 清除 URL 参数
    const newUrl = window.location.pathname
    window.history.replaceState({}, '', newUrl)
  }
}, [hasInitialMessage])
```

### 5.2 参数共享问题

在组件树中，我们确保 `useInitialMsgFromUrl` 只被调用一次，避免重复解析和状态不同步：

- ✅ 正确：只在 `ChatMessageSuper` 组件中调用 `useInitialMsgFromUrl`
- ❌ 错误：在 `SuperChat` 和 `ChatMessageSuper` 中都调用 `useInitialMsgFromUrl`

## 6. 测试场景

以下是主要测试场景：

1. **纯新会话**：访问 `/super/chat/temp_123456` 应创建全新会话，不尝试恢复历史
2. **带初始消息的新会话**：访问 `/super/chat/123456?initialMsg=Hello` 应创建新会话，不恢复历史
3. **恢复现有会话**：访问 `/super/chat/123456`（无参数）应恢复该会话的历史消息

我们提供了 Storybook 故事用于测试这些场景：

- `SuperChatWithMock.stories.tsx` - 带有模拟 API 响应的基本测试
- `SuperChatWithMockControls.stories.tsx` - 带有可配置参数的测试
- `SuperChatInteractive.stories.tsx` - 带有交互式控制面板的测试

## 7. 后续优化方向

- 添加更多边缘情况的处理（如网络错误、恢复失败等）
- 优化会话 ID 生成和临时 ID 转换机制
- 为会话实现持久化存储机制，避免刷新页面导致状态丢失
