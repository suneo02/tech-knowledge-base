# 项目深挖底稿：GEL Workspace Monorepo 工程化建设

- **定位**：面试口述脚本 & 答辩思维导图
- **基线版本**：2024.01 - 至今 | 架构师 & 项目经理

## 1. 叙事构建逻辑 (Narrative Construction)

### 模块一：电梯演讲 (The Hook / 1 min)

**[业务背景]** 随着团队扩张，我们维护着 8 个独立业务应用和 11 个公共库，面临着严重的“依赖地狱”和“重复造轮子”问题。
**[核心职责]** 我作为架构师，主导了从多仓库（Multi-repo）到 **Monorepo** 的迁移与工程化重构。
**[最大痛点]** 最痛的是 **CI 构建效率**，全量构建一次需要 40 多分钟，还经常因为内存溢出（OOM）挂掉，严重影响发版节奏。
**[解决方案]** 我基于 **pnpm Workspace + Turborepo** 搭建了新的研发底座，实现了**依赖的严格隔离**和**构建任务的智能缓存与并行调度**。
**[最终收益]** 将全量构建时间从 45 分钟压缩到了 **5 分钟**（热构建仅需 2 分钟），磁盘占用减少了 60%，统一了团队的研发规范。

### 模块二：STAR 深度复盘 (The Deep Dive)

#### S (Background / 场景痛点)
在迁移之前，我们的现状是：
1.  **依赖混乱**：我扫描了一下，整个项目里竟然有 12 个不同版本的 `lodash`，包体积臃肿不堪。
2.  **流程割裂**：每个项目的启动命令、构建脚本都不一样，新人上手很难。
3.  **效率低下**：改一个公共组件，需要 `npm publish` -> `npm install`，链路极长。

#### T (Task / 限制条件)
*   **统一性**：必须抹平不同项目的工程化差异。
*   **高性能**：必须解决 CI 慢的问题，支持增量构建。
*   **平滑迁移**：不能停下业务需求来搞重构，必须渐进式迁移。

#### A (Action / 关键决策与行动)

**1. 工具链选型：Why pnpm + Turborepo?**
*   **pnpm**：我选择了 pnpm 而不是 yarn。
    *   主要是看重它的 **Hard Link (硬链接)** 机制，大大节省了磁盘空间。
    *   更重要的是它的**严格模式**，彻底解决了“幽灵依赖”（Phantom Dependencies）的问题，这在大型项目中是巨大的安全隐患。
*   **Turborepo**：对比了 Lerna 和 Nx。
    *   Turbo 基于 Go 编写，性能极快。
    *   它的 **Remote Cache (远程缓存)** 机制非常契合我们的痛点——CI 可以直接复用上次构建的产物，只构建变动的包。

**2. 核心攻坚：智能 CI 调度器 (Smart CI Scheduler)**
*   **问题**：CI 环境网络不稳定，简单的 `pnpm -r build` 一旦某个包失败就全盘重来。
*   **解决**：我写了一个 Node.js 调度脚本 `scripts/local-ci.js`。
    *   **拓扑排序**：分析依赖关系，先构建底层的 `gel-ui` / `gel-util`，再并行构建上层应用。
    *   **智能重试**：捕获子进程的 Exit Code，如果构建失败，自动进入重试队列（Retry Queue），最大重试 3 次。这极大地提高了流水线的通过率。

**3. 体验升级：统一 CLI**
*   封装了 `pnpm run start` 交互式命令行，自动注入环境变量，新同学只需要一行命令就能启动任何一个子应用，不用再去记各种端口号。

#### R (Result / 结果与收益)
*   **速度**：冷构建 12 分钟，热构建 2 分钟（利用缓存）。
*   **质量**：消灭了幽灵依赖，统一了依赖版本。
*   **规范**：所有项目共享一套 ESLint/Prettier/TSConfig 配置，代码风格完全统一。

## 2. 防御性推演 (Defensive Strategy)

### 策略 A：技术选型质疑 (Trade-off)

*   **Trigger**：为什么不直接用 Nx？Nx 功能不是更强大吗？
*   **A (脚本)**：
    *   **承认优势**：Nx 确实功能很全，插件生态丰富。
    *   **抛出场景**：但我们的项目是渐进式迁移的，团队成员对新工具的学习成本比较敏感。
    *   **对比收益**：Turborepo 的配置非常简单（只有一个 `turbo.json`），对现有代码的侵入性几乎为零。我们需要的是**极致的构建速度**和**简单的缓存逻辑**，Turbo 完美切中痛点，且它是 Vercel 出品，生态兼容性（特别是 Next.js）更好。

### 策略 B：深度原理挖掘 (Under the Hood)

*   **Trigger**：pnpm 是怎么解决幽灵依赖的？
*   **A (脚本)**：
    *   **原理**：npm/yarn v1 会把所有依赖扁平化铺在 `node_modules` 根目录，导致代码可以引用 `package.json` 里没写的包。
    *   **pnpm 机制**：pnpm 使用符号链接（Symlink）构建非扁平化的 `node_modules` 结构。只有在 `package.json` 显式声明的包，才能在 `node_modules` 根目录找到软链，否则 Node.js 的解析算法根本找不到，从而在编译期就暴露问题。

### 策略 C：不足与反思 (Deficiency & Pivot)

*   **Trigger**：Monorepo 有带来什么新问题吗？
*   **A (脚本)**：
    *   **问题**：工具脚本的依赖管理容易被忽视。
    *   **案例**：有次 CI 挂了，因为我写的脚本里用了 `prompts` 库，但我忘了把它加到 `devDependencies` 里。本地能跑是因为恰好别的包安装了这个库（虽然 pnpm 严格，但脚本运行环境有时比较特殊）。
    *   **Pivot (改进)**：我把所有工程化脚本都移到了独立的 `packages/scripts` 包里进行统一管理，并在 `preinstall` 钩子里增加了环境一致性检查。

## 3. 模拟对练 (Simulation)

*   **Round 1**：Monorepo 怎么做权限控制？（答：代码仓库层面很难做细粒度控制，我们主要通过 Code Review (CODEOWNERS) 机制，核心库的修改必须由架构组 Review。）
*   **Round 2**：版本号怎么管理？（答：使用 Changesets。它可以自动根据 commit message 生成 changelog，并自动升级版本号，支持 Fixed 和 Independent 两种模式。）
*   **Round 3**：Vite 在 Monorepo 下开发体验如何？（答：非常好。配置 `resolve.alias` 指向源码目录，可以实现修改库代码，应用端毫秒级热更，无需构建。）
