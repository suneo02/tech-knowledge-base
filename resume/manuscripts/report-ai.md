# 项目深挖底稿：Report-AI 报告生成应用

- **定位**：面试口述脚本 & 答辩思维导图
- **基线版本**：2024.03 - 2024.10 | 项目负责人 & 核心开发

## 1. 叙事构建逻辑 (Narrative Construction)

### 模块一：电梯演讲 (The Hook / 1 min)

**[业务背景]** 这是一个面向金融行业的企业级 AI 报告生成平台，支持生成长达 50 页的专业研报，并支持多人协作。
**[核心职责]** 我负责最核心的**编辑器状态管理**和**AI 流式注水引擎**。
**[最大痛点]** 最难的是处理 **AI 生成与用户编辑的并发冲突**。想象一下，AI 正在流式写入第 3 章，而用户同时在修改第 1 章，这时候触发自动保存，很容易发生数据覆盖或 UI 抖动。
**[解决方案]** 我设计了**三层状态一致性模型 (Three-Layer Consistency)**，并引入了 **Single-Flight 保存队列**和 **RAF 流式缓冲策略**。
**[最终收益]** 完美解决了长文档的协同编辑冲突，保证了 AI 生成过程中编辑器依然丝滑流畅（60FPS），数据零丢失。

### 模块二：STAR 深度复盘 (The Deep Dive)

#### S (Background / 场景痛点)
这个项目的技术复杂度远超普通的 CRUD。
1.  **文档极长**：50+ 页，DOM 节点数万。
2.  **状态极乱**：服务端有数据（Canonical），Redux 有元数据（Draft），编辑器里有 UI 状态。这三者必须实时同步。
3.  **并发冲突**：AI 在写，人在写，自动保存还在后台跑，这三件事是并发发生的。

#### T (Task / 限制条件)
*   **一致性**：绝对不能丢用户的数据，也不能丢 AI 生成的数据。
*   **性能**：流式生成时，不能阻塞用户输入。

#### A (Action / 关键决策与行动)

**1. 架构设计：三层状态一致性模型**
*   **分层管理**：
    *   **Canonical (服务端)**：作为 Single Source of Truth。
    *   **Draft (Redux)**：只存元数据（章节 ID、标题、Hash），做轻量级 diff。
    *   **UI (TinyMCE)**：通过双向绑定与 Draft 通信。
*   **数据流**：我规定了严格的单向数据流。Input -> TinyMCE -> Normalize -> Hash -> Draft -> Auto Save。

**2. 核心攻坚：并发控制与防覆盖**
*   **问题**：用户 A 在写，AI 也在写，自动保存触发了。如果简单的 `save(content)`，等后端返回结果时，用户可能又输入了新内容，这时候如果用后端数据覆盖前端，用户的新输入就丢了。
*   **解决**：
    *   **Single-Flight Queue**：保存请求必须串行，前一个没回来，后一个不能发。
    *   **DocHash (文档哈希)**：每次保存前计算内容 Hash。保存回来后，只更新 `baselineHash`，**绝对不重置编辑器内容**，除非后端明确返回了“需要清洗”的信号。
    *   **Optimistic UI**：保存期间假定成功，减少界面冻结感。

**3. 性能优化：流式注水 (Streaming Hydration)**
*   **复用经验**：借鉴了 AI-Chat 的经验，我再次使用了 **RAF 缓冲策略**。
*   **适配编辑器**：TinyMCE 的 `setContent` 开销很大。我将 16ms 内收到的所有 AI Token 合并，每帧只调用一次 `editor.insertContent`。
*   **结果**：把每秒 50 次的 DOM 操作降到了 60 帧以内的平滑更新，彻底解决了“打字机卡顿”问题。

#### R (Result / 结果与收益)
*   **体验**：用户在 AI 生成的同时可以无感编辑其他章节。
*   **稳定**：上线后未发生一起数据覆盖事故。
*   **沉淀**：这套多层状态管理方案成为了团队处理复杂表单的标准范式。

## 2. 防御性推演 (Defensive Strategy)

### 策略 A：技术选型质疑 (Trade-off)

*   **Trigger**：为什么选 TinyMCE？它不是很重吗？为什么不用 Slate.js？
*   **A (脚本)**：
    *   **承认缺点**：TinyMCE 确实重，包体积大。
    *   **场景决定**：但我们的用户是金融分析师，他们需要极其复杂的 Word 格式粘贴、分页预览和表格操作。
    *   **对比收益**：Slate.js 虽然灵活，但要实现完美的 Word 粘贴兼容和分页逻辑，相当于自己写半个 Word，成本太高。TinyMCE 生态成熟，虽然重但稳（Robust）。我们通过按需加载插件，把体积控制在了可接受范围内。

### 策略 B：深度原理挖掘 (Under the Hood)

*   **Trigger**：三层状态同步具体是怎么做的？
*   **A (脚本)**：
    *   **核心是 Hash**。
    *   TinyMCE 内容变化触发 `onChange`，经过归一化（Normalize）处理（去除无关的 HTML 噪音）后计算 Hash。
    *   这个 Hash 存入 Redux 的 Draft 层。
    *   Draft 层对比 `currentHash` 和 `baselineHash`（上次保存的 Hash）。
    *   如果不一致，标记为 `dirty`，触发 Debounce 自动保存。
    *   保存成功后，更新 `baselineHash` = `currentHash`。

### 策略 C：不足与反思 (Deficiency & Pivot)

*   **Trigger**：项目中有遇到过严重的 Bug 吗？
*   **A (脚本)**：
    *   **事故**：有。早期版本，自动保存成功后，我会用后端返回的数据全量刷新编辑器。
    *   **场景**：有次网络很卡，保存请求走了 5 秒。这 5 秒内用户敲了一段话。请求回来后，旧数据直接把用户的新话覆盖了。
    *   **Pivot**：这让我意识到**前端状态的权威性**。在编辑场景下，用户的输入才是最新的 Truth，后端只是备份。所以我改成了“只更新元数据，不触碰编辑器内容”的策略。

## 3. 模拟对练 (Simulation)

*   **Round 1**：大文档（50页）计算 Hash 会卡吗？（答：会。所以使用了 `requestIdleCallback` 在空闲时计算，或者使用 Web Worker 离线计算。）
*   **Round 2**：SSE 连接断了怎么恢复上下文？（答：请求头带上 `Last-Event-ID`，后端根据 ID 续传。）
*   **Round 3**：如何处理多人同时编辑同一个章节？（答：目前采用悲观锁（Pessimistic Locking），一人编辑时其他人只读。未来计划引入 OT/CRDT 算法实现实时协同。）
